diff --git a/dist/index.d.ts b/dist/index.d.ts
index 48e2f6263c6ee4c75d7e5c28733e64f6ebe92200..00d0729c4a3cbf9a48e8e1e962c7e2b256b75eba 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -7,6 +7,7 @@ declare const openaiCompatibleProviderOptions: z.ZodObject<{
     user: z.ZodOptional<z.ZodString>;
     reasoningEffort: z.ZodOptional<z.ZodString>;
     textVerbosity: z.ZodOptional<z.ZodString>;
+    sendReasoning: z.ZodOptional<z.ZodBoolean>;
 }, z.core.$strip>;
 type OpenAICompatibleProviderOptions = z.infer<typeof openaiCompatibleProviderOptions>;
 
diff --git a/dist/index.js b/dist/index.js
index da237bb35b7fa8e24b37cd861ee73dfc51cdfc72..b3060fbaf010e30b64df55302807828e5bfe0f9a 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -41,7 +41,7 @@ function getOpenAIMetadata(message) {
   var _a, _b;
   return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
 }
-function convertToOpenAICompatibleChatMessages(prompt) {
+function convertToOpenAICompatibleChatMessages({prompt, options}) {
   const messages = [];
   for (const { role, content, ...message } of prompt) {
     const metadata = getOpenAIMetadata({ ...message });
@@ -91,6 +91,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
       }
       case "assistant": {
         let text = "";
+        let reasoning_text = "";
         const toolCalls = [];
         for (const part of content) {
           const partMetadata = getOpenAIMetadata(part);
@@ -99,6 +100,12 @@ function convertToOpenAICompatibleChatMessages(prompt) {
               text += part.text;
               break;
             }
+            case "reasoning": {
+              if (options.sendReasoning) {
+                reasoning_text += part.text;
+              }
+              break;
+            }
             case "tool-call": {
               toolCalls.push({
                 id: part.toolCallId,
@@ -116,6 +123,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
         messages.push({
           role: "assistant",
           content: text,
+          reasoning_content: reasoning_text ?? undefined,
           tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
           ...metadata
         });
@@ -200,7 +208,8 @@ var openaiCompatibleProviderOptions = import_v4.z.object({
   /**
    * Controls the verbosity of the generated text. Defaults to `medium`.
    */
-  textVerbosity: import_v4.z.string().optional()
+  textVerbosity: import_v4.z.string().optional(),
+  sendReasoning: import_v4.z.boolean().optional()
 });
 
 // src/openai-compatible-error.ts
@@ -378,7 +387,7 @@ var OpenAICompatibleChatLanguageModel = class {
         reasoning_effort: compatibleOptions.reasoningEffort,
         verbosity: compatibleOptions.textVerbosity,
         // messages:
-        messages: convertToOpenAICompatibleChatMessages(prompt),
+        messages: convertToOpenAICompatibleChatMessages({prompt, options: compatibleOptions}),
         // tools:
         tools: openaiTools,
         tool_choice: openaiToolChoice
@@ -421,6 +430,17 @@ var OpenAICompatibleChatLanguageModel = class {
         text: reasoning
       });
     }
+    if (choice.message.images) {
+      for (const image of choice.message.images) {
+        const match1 = image.image_url.url.match(/^data:([^;]+)/)
+        const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+        content.push({
+          type: 'file',
+          mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+          data: match2 ? match2[1] : image.image_url.url,
+        });
+      }
+    }
     if (choice.message.tool_calls != null) {
       for (const toolCall of choice.message.tool_calls) {
         content.push({
@@ -598,6 +618,17 @@ var OpenAICompatibleChatLanguageModel = class {
                 delta: delta.content
               });
             }
+            if (delta.images) {
+              for (const image of delta.images) {
+                const match1 = image.image_url.url.match(/^data:([^;]+)/)
+                const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+                controller.enqueue({
+                  type: 'file',
+                  mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+                  data: match2 ? match2[1] : image.image_url.url,
+                });
+              }
+            }
             if (delta.tool_calls != null) {
               for (const toolCallDelta of delta.tool_calls) {
                 const index = toolCallDelta.index;
@@ -765,6 +796,14 @@ var OpenAICompatibleChatResponseSchema = import_v43.z.object({
               arguments: import_v43.z.string()
             })
           })
+        ).nullish(),
+        images: import_v43.z.array(
+          import_v43.z.object({
+            type: import_v43.z.literal('image_url'),
+            image_url: import_v43.z.object({
+              url: import_v43.z.string(),
+            })
+          })
         ).nullish()
       }),
       finish_reason: import_v43.z.string().nullish()
@@ -795,6 +834,14 @@ var createOpenAICompatibleChatChunkSchema = (errorSchema) => import_v43.z.union(
                 arguments: import_v43.z.string().nullish()
               })
             })
+          ).nullish(),
+          images: import_v43.z.array(
+            import_v43.z.object({
+              type: import_v43.z.literal('image_url'),
+              image_url: import_v43.z.object({
+                url: import_v43.z.string(),
+              })
+            })
           ).nullish()
         }).nullish(),
         finish_reason: import_v43.z.string().nullish()
diff --git a/dist/index.mjs b/dist/index.mjs
index a809a7aa0e148bfd43e01dd7b018568b151c8ad5..565b605eeacd9830b2b0e817e58ad0c5700264de 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -23,7 +23,7 @@ function getOpenAIMetadata(message) {
   var _a, _b;
   return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
 }
-function convertToOpenAICompatibleChatMessages(prompt) {
+function convertToOpenAICompatibleChatMessages({prompt, options}) {
   const messages = [];
   for (const { role, content, ...message } of prompt) {
     const metadata = getOpenAIMetadata({ ...message });
@@ -73,6 +73,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
       }
       case "assistant": {
         let text = "";
+        let reasoning_text = "";
         const toolCalls = [];
         for (const part of content) {
           const partMetadata = getOpenAIMetadata(part);
@@ -81,6 +82,12 @@ function convertToOpenAICompatibleChatMessages(prompt) {
               text += part.text;
               break;
             }
+            case "reasoning": {
+              if (options.sendReasoning) {
+                reasoning_text += part.text;
+              }
+              break;
+            }
             case "tool-call": {
               toolCalls.push({
                 id: part.toolCallId,
@@ -98,6 +105,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
         messages.push({
           role: "assistant",
           content: text,
+          reasoning_content: reasoning_text ?? undefined,
           tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
           ...metadata
         });
@@ -182,7 +190,8 @@ var openaiCompatibleProviderOptions = z.object({
   /**
    * Controls the verbosity of the generated text. Defaults to `medium`.
    */
-  textVerbosity: z.string().optional()
+  textVerbosity: z.string().optional(),
+  sendReasoning: z.boolean().optional()
 });
 
 // src/openai-compatible-error.ts
@@ -362,7 +371,7 @@ var OpenAICompatibleChatLanguageModel = class {
         reasoning_effort: compatibleOptions.reasoningEffort,
         verbosity: compatibleOptions.textVerbosity,
         // messages:
-        messages: convertToOpenAICompatibleChatMessages(prompt),
+        messages: convertToOpenAICompatibleChatMessages({prompt, options: compatibleOptions}),
         // tools:
         tools: openaiTools,
         tool_choice: openaiToolChoice
@@ -405,6 +414,17 @@ var OpenAICompatibleChatLanguageModel = class {
         text: reasoning
       });
     }
+    if (choice.message.images) {
+      for (const image of choice.message.images) {
+        const match1 = image.image_url.url.match(/^data:([^;]+)/)
+        const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+        content.push({
+          type: 'file',
+          mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+          data: match2 ? match2[1] : image.image_url.url,
+        });
+      }
+    }
     if (choice.message.tool_calls != null) {
       for (const toolCall of choice.message.tool_calls) {
         content.push({
@@ -582,6 +602,17 @@ var OpenAICompatibleChatLanguageModel = class {
                 delta: delta.content
               });
             }
+            if (delta.images) {
+              for (const image of delta.images) {
+                const match1 = image.image_url.url.match(/^data:([^;]+)/)
+                const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+                controller.enqueue({
+                  type: 'file',
+                  mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+                  data: match2 ? match2[1] : image.image_url.url,
+                });
+              }
+            }
             if (delta.tool_calls != null) {
               for (const toolCallDelta of delta.tool_calls) {
                 const index = toolCallDelta.index;
@@ -749,6 +780,14 @@ var OpenAICompatibleChatResponseSchema = z3.object({
               arguments: z3.string()
             })
           })
+        ).nullish(),
+        images: z3.array(
+          z3.object({
+            type: z3.literal('image_url'),
+            image_url: z3.object({
+              url: z3.string(),
+            })
+          })
         ).nullish()
       }),
       finish_reason: z3.string().nullish()
@@ -779,6 +818,14 @@ var createOpenAICompatibleChatChunkSchema = (errorSchema) => z3.union([
                 arguments: z3.string().nullish()
               })
             })
+          ).nullish(),
+          images: z3.array(
+            z3.object({
+              type: z3.literal('image_url'),
+              image_url: z3.object({
+                url: z3.string(),
+              })
+            })
           ).nullish()
         }).nullish(),
         finish_reason: z3.string().nullish()
